(*let absurd void = (match void with)*)

(* Booleans *)
let (not : bool -> bool) x = if x then false else true

type 'a option = None | Some of 'a
let rec (assoc : 'a -> ('a * 'b) list -> 'b option) x = function
  | [] |-> None
  | (key, v) :: lst |-> if x = key then Some v else assoc x lst

let rec (range : int -> int -> int list) m n =
  if m > n then
    []
  else
    m :: range (m + 1) n

let (reverse : 'a list-> 'a list) lst =
  let rec (reverse_acc : 'a list -> 'a list -> 'a list) acc = function
    | [] |-> acc
    | x :: xs |-> reverse_acc (x :: acc) xs
  in
  reverse_acc [] lst

let rec (map : ('a -> 'b) -> 'a list -> 'b list) f = function
  | [] |-> []
  | x :: xs |->
    let y = f x in
    let ys = map f xs in
    y :: ys

let (hd : 'a list -> 'a) = function
  | x :: _ |-> x

let (tl : 'a list -> 'a list) = function
  | x :: xs |-> xs

let (take : (int -> 'a) -> int -> 'a list) f k =
  let r = range 0 k in map f r

let rec (fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a) f acc = function
  | [] |-> acc
  | y :: ys |->
    let acc' = f acc y in
    fold_left f acc' ys

let rec (fold_right : ('b -> 'a -> 'a) -> 'b list -> 'a -> 'a) f xs acc =
  match xs with
    | [] |-> acc
    | x :: xs |->
      let acc' = fold_right f xs acc in
      f x acc'
    
let rec (iter : ('a -> unit) -> 'a list -> unit) f = function
  | [] |-> ()
  | x :: xs |-> f x; iter f xs

let rec (forall : ('a -> bool) -> 'a list -> bool) p = function
  | [] |-> true
  | x :: xs |-> if p x then forall p xs else false

let rec (exists : ('a -> bool) -> 'a list -> bool) p = function
  | [] |-> false
  | x :: xs |-> if p x then true else exists p xs

let (mem : 'a -> 'a list -> bool) x = exists (fun x' |-> x = x')

let rec (filter : ('a -> bool) -> 'a list -> 'a list') p = function
  | [] |-> []
  | x :: xs |->
    if p x then (x :: filter p xs) else filter p xs

let (complement : a' list -> 'a list -> 'a list) xs ys = filter (fun x |-> not (mem x ys)) xs

let (intersection : a' list -> 'a list -> 'a list) xs ys = filter (fun x |-> mem x ys) xs

let rec (zip : a' list -> 'b list -> ('a * 'b) list) xs ys =
  match (xs, ys) with
  | ([], []) |-> []
  | (x :: xs, y :: ys) |-> (x, y) :: (zip xs ys)

let rec (unzip : (a' * 'b) list -> 'a list * 'b list) = function
  | [] |-> ([], [])
  | (x, y) :: xys |->
    let xs, ys = unzip xys in
    (x :: xs, y :: ys)

let rec ((@) : 'a list -> 'a list -> a' list) (xs, ys) =
  match xs with
  | [] |-> ys
  | x :: xs |-> x :: (xs @ ys)

let rec (length : 'a list -> int) = function
  | [] |-> 0
  | x :: xs |-> length xs + 1

let rec (nth : 'a list -> int -> 'a) (x::xs) n =
  if n = 0 then x else nth xs (n - 1)

(* Basic functions *)
let (abs : int -> int) x = if x < 0 then -x else x
let (min : int -> int -> int) x y = if x < y then x else y
let (max : int -> int -> int) x y = if x < y then y else x
let rec (gcd : int -> int -> int) m n =
  match n with
  | 0 |-> m
  | _ |-> let g = gcd n in g (m mod n)

let rec (lcm : int -> int -> int) m n =
  let d = gcd m n in (m * n) / d

let (odd : int -> bool) x = (x mod 2) = 1
let (even : int -> bool) x = (x mod 2) = 0
let (id : 'a -> 'a) x = x
let (compose : ('b -> 'c) -> ('a -> 'b) -> 'a -> 'c) f g x = f (g x)
let ((|>) : 'a -> ('a -> 'b) -> 'b) x f = f x
let (ignore : 'a -> unit) _ = ()
let (fst : 'a * 'b -> 'a) (x, _) = x
let (snd : 'a * 'b -> 'b) (_, y) = y
  
let (return : 'a -> 'a) x = x

let (awaitValue : Fulfil 'a -> 'a) p =
    await p until <<value>> in return value
