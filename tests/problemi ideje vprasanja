3 problem spremenljivke addition.aeff problem Runtime error: Integer expected but got a. a je topdef in tipa int. Problem je ker parser prepozna konstanto kot funkcijo.

19 
        let (id : 'a -> 'a) x = x
        let (compare : 'a -> 'b -> bool) a b =
                let a1 = id a in
                1a = b //tu je napaka uporabnika (mislil je a1 namesto 1a). 
                        //To napako aeff napačno zazna in se pritoži, da ne more 1 uporabiti na a.
                        // Aeff bi moral reči spremenljivka 1a ne obstaja. 
        run compare 5 "7"

20      let (compare : 'a -> 'b -> bool) a b =
                let (id : 'a -> 'a) x = x in
                let a1 = id a in
                a1 = b
        run compare 5 "7"

        vrne error. Samo topleveldef imajo obliko (f : tip) = abs
                                preostale imajo obliko f = (abs : tip)




22      TODO podaj typecheckerju tudi LOC


24      Bomo med vgrajene funkcije dodali getTy?

25      Kako narediti nov interpreter?  
        imamo process list skupaj z listener
        vsak process se lahko izvaja concurent/paralel/sequantial
        normalno izvajamo dokler ni IN/OUT
        Ko dobimo v enem processu OUT ga obrnemo v IN in ga pošljemo na svojem mesto
        Kako pošiljati in?
                Če si shranimo kje točno ga rabimo ga tja damo.
                Če pa ne potem pa kako? Si res želimo broadcast ali bi raje 1-1.? Če 1-1 kdo dobi če je več?
                        V DO poskusimo najrej prvemu sicer?
                        V match gremo lahko rekurzivno v vsakega
                        Kako v tuple?  

26      GO example

        var results = chanel<int>()
        var inits = chanel<int>()
        var f () =
        {
                var init_1 <- inits
                var result_1 = SlowFunction_1( init_1 )
                results <- result_1
                var init_2 <- inipts
                var result_2 = SlowFunction_2( init_2 )
                results <- result_2
        } 
        //f mora vračati unit
        go f

        init <- 1
        ...working some staff
        init <- 2


        var r0 = SlowFunction_3( 3 ) //
        print(SlowFunction_3 is finished)

        var r1 <- results
        print(SlowFunction_1 is finished too)

        var r2 <- results
        print(All SlowFunctions are finished)

        return (r1, r2)




        AEFF counter part

        operation results : int
        operation inits : int

        let f : unit -> unit =

                let promise inits i |-> i
                as inits_promise in

                await <<inits_promise>> until init_1 in   
                let result_1 = SlowFunction_1( init_1 ) in
                send result result_1;

                await <<inits_promise>> until init_2 in
                let result_2 = SlowFunction_2( init_2 ) in
                send result result_2

        run f()

        run     promise result r |-> r
                as p in return p

                send inits 1;
                ...working some staff
                in
                send inits 2;

                let r0 = SlowFunction_3( 3 )
                let _ = send print "SlowFunction_3 is finished" return() in

                await <<p>> until r1 in 
                send print "SlowFunction_1 is finished too" return() in

                await <<p>> until r2 in
                send print "All SlowFunctions are finished" return() in

                return (r1,r2)


28      na strani 24:6 asyn eff kaj je batchSizeResponse? ni to operacija, ki je nismo nikjer definirali?


29      24:11   Ground type 𝐴, 𝐵 ::= ... brez A -> B 

        we assign a fixed signature op : 𝐴op that specifies the type 𝐴op of the payload
of the corresponding signal or interrupt. Crucially, in order to be able to later prove that 𝜆æ is type
safe (see Theorem 3.3, but also the relevant discussion in Section 6), we restrict these signatures to
ground types 𝐴, 𝐵, . . ., which include standard base, unit, empty, product, and sum types.

        ampak 
        async.aeff 
        ima
        operation question : unit -> int

30      line coments in aeff??

31      op <- v 
        sugar za 
        send op v 

        in obratno

        v <- op
        sugar za
        promise op v' |-> v' as p in
        await <<p>> until v
        ???

32      Kaj se zgodi če imamo InProc(opB, e,  InProc(opA, e, Run await op11 ...await opX...)  ) kjer je X = 1|2 {A,B} = {1,2}

        Namesto InProc = op * e * process
        bi imeli ali 
                InProc = (op * e) list * process //seznam operacij ki čakajo da jih nekam damo
                ali
                process = (op * e) list * (op * e) list * comp//seznam in, seznam out, computation?


33      V "shared memory"/state so samo toplet, tydef, opdef ? torej lahko vsakemu threadu na začetku damo svoj state in od zdej naprej vsak skrbi za svojega?
        Sedaj bi bilo dosti enostavno delati nove threade? Novemu threadu samo damo kopijo state in predpisan computation?


34      Kaj se zgodi če op = op' v
        Commutativity of signals with interrupt handlers 24:9
        promise (op 𝑥 ↦→ 𝑀) as 𝑝 in ↑ op′
        (𝑉 , 𝑁) { ↑ op′
        (𝑉 , promise (op 𝑥 ↦→ 𝑀) as 𝑝 in 𝑁)
        ?


35      V interpreter je povno možnosti, ki niso možne, glede na to, da ima program tip.
        Vendar tega match ne ve in mu moramo podati insert. 
        Se da kako povedati match da bi to prepoznal avtomatsko?


