3 problem spremenljivke addition.aeff problem Runtime error: Integer expected but got a. a je topdef in tipa int. Problem je ker parser prepozna konstanto kot funkcijo.

19 
        let (id : 'a -> 'a) x = x
        let (compare : 'a -> 'b -> bool) a b =
                let a1 = id a in
                1a = b //tu je napaka uporabnika (mislil je a1 namesto 1a). 
                        //To napako aeff napaƒçno zazna in se prito≈æi, da ne more 1 uporabiti na a.
                        // Aeff bi moral reƒçi spremenljivka 1a ne obstaja. 
        run compare 5 "7"

20      let (compare : 'a -> 'b -> bool) a b =
                let (id : 'a -> 'a) x = x in
                let a1 = id a in
                a1 = b
        run compare 5 "7"

        vrne error. Samo topleveldef imajo obliko (f : tip) = abs
                                preostale imajo obliko f = (abs : tip)



22      TODO podaj typecheckerju tudi LOC


24      Bomo med vgrajene funkcije dodali getTy?



26      GO example

        var results = chanel<int>()
        var inits = chanel<int>()
        var f () =
        {
                var init_1 <- inits
                var result_1 = SlowFunction_1( init_1 )
                results <- result_1
                var init_2 <- inipts
                var result_2 = SlowFunction_2( init_2 )
                results <- result_2
        } 
        //f mora vraƒçati unit
        go f()

        init <- 1
        ...working some staff
        init <- 2


        var r0 = SlowFunction_3( 3 ) //
        print(SlowFunction_3 is finished)

        var r1 <- results
        print(SlowFunction_1 is finished too)

        var r2 <- results
        print(All SlowFunctions are finished)

        return (r1, r2)




        AEFF counter part

        operation results : int
        operation inits : int

        let f : unit -> unit =
            let promise inits init_1 |-> (
              let result_1 = SlowFunction_1( init_1 ) in
              send result result_1;
              let promise inits init_2 |->
                let result_2 = SlowFunction_2( init_2 ) in
                send result result_2;
                return <<()>>
            )

        run f()

        run
          send inits 1;
          send inits 2;
          let r0 = SlowFunction_3( 3 ) in
          let _ = send print "SlowFunction_3 is finished" return() in
          promise results r1 |->

     promise result r |-> r
                as p in return p

                send inits 1;
                ...working some staff
                in
                send inits 2;

                let r0 = SlowFunction_3( 3 )

                await <<p>> until r1 in 
                send print "SlowFunction_1 is finished too" return() in

                await <<p>> until r2 in
                send print "All SlowFunctions are finished" return() in

                return (r1,r2)



29      24:11   Ground type ùê¥, ùêµ ::= ... brez A -> B 

        we assign a fixed signature op : ùê¥op that specifies the type ùê¥op of the payload
of the corresponding signal or interrupt. Crucially, in order to be able to later prove that ùúÜ√¶ is type
safe (see Theorem 3.3, but also the relevant discussion in Section 6), we restrict these signatures to
ground types ùê¥, ùêµ, . . ., which include standard base, unit, empty, product, and sum types.

        ampak 
        async.aeff 
        ima
        operation question : unit -> int


30      Ast.Out damo na seznam in obdelamo na koncu velikega koraka namesto, da bi poƒçasi pripraval na vrh.
        Bi lahko tako tudi Ast.Promise dali na nek seznam, namesto da poƒçasi potuje vn?


31      bug 
        guarded promise ne delajo kot bi morali
        reproduce bug:
        run remoteCall.aeff

        expected
        yt() = 240

        bugedd result
        yt() = 360