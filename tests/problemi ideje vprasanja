3 problem spremenljivke addition.aeff problem Runtime error: Integer expected but got a. a je topdef in tipa int. Problem je ker parser prepozna konstanto kot funkcijo.

19 
        let (id : 'a -> 'a) x = x
        let (compare : 'a -> 'b -> bool) a b =
                let a1 = id a in
                1a = b //tu je napaka uporabnika (mislil je a1 namesto 1a). 
                        //To napako aeff napaÄno zazna in se pritoÅ¾i, da ne more 1 uporabiti na a.
                        // Aeff bi moral reÄi spremenljivka 1a ne obstaja. 
        run compare 5 "7"

20      let (compare : 'a -> 'b -> bool) a b =
                let (id : 'a -> 'a) x = x in
                let a1 = id a in
                a1 = b
        run compare 5 "7"

        vrne error. Samo topleveldef imajo obliko (f : tip) = abs
                                preostale imajo obliko f = (abs : tip)



22      TODO podaj typecheckerju tudi LOC


24      Bomo med vgrajene funkcije dodali getTy?



25      Kako izvajamo program?  
        normalno izvajamo dokler ni IN/OUT
        Ko dobimo v enem processu OUT ga poÅ¡ljemo ven in obrnemo v IN v drugih. 
        Kako poÅ¡iljati in?
                ÄŒe si shranimo promise. Kako si jih shranimo? promise bi moral biti ovit v comp, 
                ki bi imel shranjen pointer na naslednjo comp, 
                da bi lahko ta comp(promise) zamenjali z do. ne pa vrednosti
                
        Do takrat pointerjev ali gruge reÅ¡itve.
                kako izvajati OUT

                        Kaj se zgodi Äe op = op' v
                        Commutativity of signals with interrupt handlers 24:9
                        promise (op ğ‘¥ â†¦â†’ ğ‘€) as ğ‘ in â†‘ opâ€²
                        (ğ‘‰ , ğ‘) { â†‘ opâ€²
                        (ğ‘‰ , promise (op ğ‘¥ â†¦â†’ ğ‘€) as ğ‘ in ğ‘)
                        ?

                        Out lahko vedno takoj poÅ¡ljemo ven do konca?

                Kako izvajati IN

                        36

                        

                        Namesto InProc = op * e * process
                                bi imeli ali 
                                        InProc = (op * e) list * process //seznam operacij ki Äakajo da jih nekam damo
                                        ali
                                        process = (op * e) list * (op * e) list * comp//seznam in, seznam out, computation?


26      GO example

        var results = chanel<int>()
        var inits = chanel<int>()
        var f () =
        {
                var init_1 <- inits
                var result_1 = SlowFunction_1( init_1 )
                results <- result_1
                var init_2 <- inipts
                var result_2 = SlowFunction_2( init_2 )
                results <- result_2
        } 
        //f mora vraÄati unit
        go f()

        init <- 1
        ...working some staff
        init <- 2


        var r0 = SlowFunction_3( 3 ) //
        print(SlowFunction_3 is finished)

        var r1 <- results
        print(SlowFunction_1 is finished too)

        var r2 <- results
        print(All SlowFunctions are finished)

        return (r1, r2)




        AEFF counter part

        operation results : int
        operation inits : int

        let f : unit -> unit =

                let promise inits i |-> i
                as inits_promise in

                await <<inits_promise>> until init_1 in   
                let result_1 = SlowFunction_1( init_1 ) in
                send result result_1;

                await <<inits_promise>> until init_2 in
                let result_2 = SlowFunction_2( init_2 ) in
                send result result_2

        run f()

        run     promise result r |-> r
                as p in return p

                send inits 1;
                ...working some staff
                in
                send inits 2;

                let r0 = SlowFunction_3( 3 )
                let _ = send print "SlowFunction_3 is finished" return() in

                await <<p>> until r1 in 
                send print "SlowFunction_1 is finished too" return() in

                await <<p>> until r2 in
                send print "All SlowFunctions are finished" return() in

                return (r1,r2)


28      na strani 24:6 asyn eff kaj je batchSizeResponse? ni to operacija, ki je nismo nikjer definirali?


29      24:11   Ground type ğ´, ğµ ::= ... brez A -> B 

        we assign a fixed signature op : ğ´op that specifies the type ğ´op of the payload
of the corresponding signal or interrupt. Crucially, in order to be able to later prove that ğœ†Ã¦ is type
safe (see Theorem 3.3, but also the relevant discussion in Section 6), we restrict these signatures to
ground types ğ´, ğµ, . . ., which include standard base, unit, empty, product, and sum types.

        ampak 
        async.aeff 
        ima
        operation question : unit -> int

30      line coments in aeff??

31      op <- v 
        sugar za 
        send op v 

        in obratno

        v <- op
        sugar za
        promise op v' |-> v' as p in
        await <<p>> until v
        ???


33      V "shared memory"/state so samo toplet, tydef, opdef ? torej lahko vsakemu threadu na zaÄetku damo svoj state in od zdej naprej vsak skrbi za svojega?
        //Sedaj bi bilo dosti enostavno delati nove threade? Novemu threadu samo damo kopijo state in predpisan computation?



35      V interpreter je povno moÅ¾nosti, ki niso moÅ¾ne, glede na to, da ima program tip.
        Vendar tega match ne ve in mu moramo podati insert. 
        Se da kako povedati match da bi to prepoznal avtomatsko?


36      a)      Kaj Äe dobimo recimo
                        â†“ op (ğ‘‰ , match... )
                        ÄŒe nimamo navedenega pravila, naredimo korak v match..., 
                        dokler ne dobimo Å¾eljenega pravila za interupt propagation?

        b)      Kaj se zgodi Äe imamo 
                InProc(opA, e, Run promise opB ...as p in await p ...)    
                in pride od nekod opB, e  
                ~>
                InProc(opB, e,   InProc(opA, e, Run promise opB ...as p in await p ...)   ) 
                ~>
                ?

        c)      V kaj se evaluira
                InProc(opB, e,  InProc(opA, e, Run promise opY ... as p1 in await p1 ... promise opX ... as p2 in await p2...)  ), kjer je       X â‚¬ {1,2}       Y â‚¬ {1,37}       {A,B} = {1,2}
                ~>
                ?

                                     