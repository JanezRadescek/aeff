3 problem spremenljivke addition.aeff problem Runtime error: Integer expected but got a. a je topdef in tipa int. Problem je ker parser prepozna konstanto kot funkcijo.

19 
        let (id : 'a -> 'a) x = x
        let (compare : 'a -> 'b -> bool) a b =
                let a1 = id a in
                1a = b //tu je napaka uporabnika (mislil je a1 namesto 1a). 
                        //To napako aeff napaÄno zazna in se pritoÅ¾i, da ne more 1 uporabiti na a.
                        // Aeff bi moral reÄi spremenljivka 1a ne obstaja. 
        run compare 5 "7"

20      let (compare : 'a -> 'b -> bool) a b =
                let (id : 'a -> 'a) x = x in
                let a1 = id a in
                a1 = b
        run compare 5 "7"

        vrne error. Samo topleveldef imajo obliko (f : tip) = abs
                                preostale imajo obliko f = (abs : tip)



22      TODO podaj typecheckerju tudi LOC


24      Bomo med vgrajene funkcije dodali getTy?



25      Kako izvajamo program?  
        normalno izvajamo dokler ni IN/OUT
        Ko dobimo v enem processu OUT ga poÅ¡ljemo ven in obrnemo v IN v drugih. 
        Kako poÅ¡iljati in?
                ÄŒe si shranimo promise. Kako si jih shranimo? promise bi moral biti ovit v comp, 
                ki bi imel shranjen pointer na naslednjo comp, 
                da bi lahko ta comp(promise) zamenjali z do. ne pa vrednosti
                
        Do takrat pointerjev ali gruge reÅ¡itve.
                kako izvajati OUT

                        Kaj se zgodi Äe op = op' v
                        Commutativity of signals with interrupt handlers 24:9
                        promise (op ğ‘¥ â†¦â†’ ğ‘€) as ğ‘ in â†‘ opâ€²
                        (ğ‘‰ , ğ‘) { â†‘ opâ€²
                        (ğ‘‰ , promise (op ğ‘¥ â†¦â†’ ğ‘€) as ğ‘ in ğ‘)
                        ?

                        Out lahko vedno takoj poÅ¡ljemo ven do konca?

                Kako izvajati IN

                        36

                        

                        Namesto InProc = op * e * process
                                bi imeli ali 
                                        InProc = (op * e) list * process //seznam operacij ki Äakajo da jih nekam damo
                                        ali
                                        process = (op * e) list * (op * e) list * comp//seznam in, seznam out, computation?


26      GO example

        var results = chanel<int>()
        var inits = chanel<int>()
        var f () =
        {
                var init_1 <- inits
                var result_1 = SlowFunction_1( init_1 )
                results <- result_1
                var init_2 <- inipts
                var result_2 = SlowFunction_2( init_2 )
                results <- result_2
        } 
        //f mora vraÄati unit
        go f()

        init <- 1
        ...working some staff
        init <- 2


        var r0 = SlowFunction_3( 3 ) //
        print(SlowFunction_3 is finished)

        var r1 <- results
        print(SlowFunction_1 is finished too)

        var r2 <- results
        print(All SlowFunctions are finished)

        return (r1, r2)




        AEFF counter part

        operation results : int
        operation inits : int

        let f : unit -> unit =
            let promise inits init_1 |-> (
              let result_1 = SlowFunction_1( init_1 ) in
              send result result_1;
              let promise inits init_2 |->
                let result_2 = SlowFunction_2( init_2 ) in
                send result result_2;
                return <<()>>
            )

        run f()

        run
          send inits 1;
          send inits 2;
          let r0 = SlowFunction_3( 3 ) in
          let _ = send print "SlowFunction_3 is finished" return() in
          promise results r1 |->

     promise result r |-> r
                as p in return p

                send inits 1;
                ...working some staff
                in
                send inits 2;

                let r0 = SlowFunction_3( 3 )

                await <<p>> until r1 in 
                send print "SlowFunction_1 is finished too" return() in

                await <<p>> until r2 in
                send print "All SlowFunctions are finished" return() in

                return (r1,r2)



29      24:11   Ground type ğ´, ğµ ::= ... brez A -> B 

        we assign a fixed signature op : ğ´op that specifies the type ğ´op of the payload
of the corresponding signal or interrupt. Crucially, in order to be able to later prove that ğœ†Ã¦ is type
safe (see Theorem 3.3, but also the relevant discussion in Section 6), we restrict these signatures to
ground types ğ´, ğµ, . . ., which include standard base, unit, empty, product, and sum types.

        ampak 
        async.aeff 
        ima
        operation question : unit -> int



36      a)      Kaj Äe dobimo recimo
                        â†“ op (ğ‘‰ , match... )
                        ÄŒe nimamo navedenega pravila, naredimo korak v match..., 
                        dokler ne dobimo Å¾eljenega pravila za interupt propagation?

                DA, â†“ op (ğ‘‰ , ...) je evalvacijski kontekst, zato se ta, notri naprej delajo koraki

        b)      Kaj se zgodi Äe imamo 
                InProc(opA, e, Run promise opB ...as p in await p ...)    
                in pride od nekod opB, e  
                ~>
                InProc(opB, e,   InProc(opA, e, Run promise opB ...as p in await p ...)   ) 
                ~>
                InProc(opB, e,  Run  InComp(opA, e, promise opB ...as p in await p ...)   ) 
                ~> (tu je tudi varianta v Run (Incomp A (Incomp B (...))))
                InProc(opB, e,  Run  promise opB ...as p in InComp(opA, e, await p ...)   ) 
                ~>
                Run InComp(opB, e, promise opB ...as p in InComp(opA, e, await p ...)   ) 
                ~>
                Run let p = ... in InComp(opB, e, InComp(opA, e, await p ...))
                ~>
                ...


37      Äez kodo kar je Å¾e narejeno pa Äe je prava smer
        star interpreter sem v celoti zakomentiral, ker bi rad naredil od zaÄetka, ker sicer bodo deli kode, ki bodo delali pa ne bom vedel zakaj, 
        potem se bo pa nekoÄ nekaj spremenilo, pa nebodo veÄ delali, pa tudi ne bom vedel zakaj ali kako popraviti. 

        thread = run comp + seznam operacij, ki jih hoÄemo. stanje
        //glede na Danel verzijo gre seznam operacij ki jih posluÅ¡amo stran, in ga nadomestimo z pointerjem na global queue operacij.

        run initialize all and call run_rec 
        run_rec poganjaj induvidualne threade dokler se ne bodo prekinili. Resolve operation reÅ¡i operacije in interupte. ÄŒe je kakÅ¡en thread, ki Å¡e ni konÄan se rekurzivno pokliÄi.
        run_thread ÄŒe smo Ready predaj run_comp
        run_comp rekurzivno izvajaj comp. in na koncu odloÄi v kakÅ¡nem stanju smo se ustavili.

        resolve operations vsem thredom, ki so op_out vzemi operacijo, jo daj na global queue in nato vsakemu thredu daj operacije, ki jih hoÄe, Äe jih hoÄe.
                                     