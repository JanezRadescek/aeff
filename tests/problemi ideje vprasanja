3 problem spremenljivke addition.aeff problem Runtime error: Integer expected but got a. a je topdef in tipa int. Problem je ker parser prepozna konstanto kot funkcijo.

19 
        let (id : 'a -> 'a) x = x
        let (compare : 'a -> 'b -> bool) a b =
                let a1 = id a in
                1a = b //tu je napaka uporabnika (mislil je a1 namesto 1a). 
                        //To napako aeff napaÄno zazna in se pritoÅ¾i, da ne more 1 uporabiti na a.
                        // Aeff bi moral reÄi spremenljivka 1a ne obstaja. 
        run compare 5 "7"

20      let (compare : 'a -> 'b -> bool) a b =
                let (id : 'a -> 'a) x = x in
                let a1 = id a in
                a1 = b
        run compare 5 "7"

        vrne error. Samo topleveldef imajo obliko (f : tip) = abs
                                preostale imajo obliko f = (abs : tip)



22      TODO podaj typecheckerju tudi LOC


24      Bomo med vgrajene funkcije dodali getTy?



25      Kako izvajamo program?  
        normalno izvajamo dokler ni IN/OUT
        Ko dobimo v enem processu OUT ga poÅ¡ljemo ven in obrnemo v IN v drugih. 
        Kako poÅ¡iljati in?
                ÄŒe si shranimo promise. Kako si jih shranimo? promise bi moral biti ovit v comp, 
                ki bi imel shranjen pointer na naslednjo comp, 
                da bi lahko ta comp(promise) zamenjali z do. ne pa vrednosti
                
        Do takrat pointerjev ali gruge reÅ¡itve.
                kako izvajati OUT

                        Kaj se zgodi Äe op = op' v
                        Commutativity of signals with interrupt handlers 24:9
                        promise (op ğ‘¥ â†¦â†’ ğ‘€) as ğ‘ in â†‘ opâ€²
                        (ğ‘‰ , ğ‘) { â†‘ opâ€²
                        (ğ‘‰ , promise (op ğ‘¥ â†¦â†’ ğ‘€) as ğ‘ in ğ‘)
                        ?

                        Out lahko vedno takoj poÅ¡ljemo ven do konca?

                Kako izvajati IN

                        36

                        

                        Namesto InProc = op * e * process
                                bi imeli ali 
                                        InProc = (op * e) list * process //seznam operacij ki Äakajo da jih nekam damo
                                        ali
                                        process = (op * e) list * (op * e) list * comp//seznam in, seznam out, computation?


26      GO example

        var results = chanel<int>()
        var inits = chanel<int>()
        var f () =
        {
                var init_1 <- inits
                var result_1 = SlowFunction_1( init_1 )
                results <- result_1
                var init_2 <- inipts
                var result_2 = SlowFunction_2( init_2 )
                results <- result_2
        } 
        //f mora vraÄati unit
        go f()

        init <- 1
        ...working some staff
        init <- 2


        var r0 = SlowFunction_3( 3 ) //
        print(SlowFunction_3 is finished)

        var r1 <- results
        print(SlowFunction_1 is finished too)

        var r2 <- results
        print(All SlowFunctions are finished)

        return (r1, r2)




        AEFF counter part

        operation results : int
        operation inits : int

        let f : unit -> unit =
            let promise inits init_1 |-> (
              let result_1 = SlowFunction_1( init_1 ) in
              send result result_1;
              let promise inits init_2 |->
                let result_2 = SlowFunction_2( init_2 ) in
                send result result_2;
                return <<()>>
            )

        run f()

        run
          send inits 1;
          send inits 2;
          let r0 = SlowFunction_3( 3 ) in
          let _ = send print "SlowFunction_3 is finished" return() in
          promise results r1 |->

     promise result r |-> r
                as p in return p

                send inits 1;
                ...working some staff
                in
                send inits 2;

                let r0 = SlowFunction_3( 3 )

                await <<p>> until r1 in 
                send print "SlowFunction_1 is finished too" return() in

                await <<p>> until r2 in
                send print "All SlowFunctions are finished" return() in

                return (r1,r2)



29      24:11   Ground type ğ´, ğµ ::= ... brez A -> B 

        we assign a fixed signature op : ğ´op that specifies the type ğ´op of the payload
of the corresponding signal or interrupt. Crucially, in order to be able to later prove that ğœ†Ã¦ is type
safe (see Theorem 3.3, but also the relevant discussion in Section 6), we restrict these signatures to
ground types ğ´, ğµ, . . ., which include standard base, unit, empty, product, and sum types.

        ampak 
        async.aeff 
        ima
        operation question : unit -> int



36      a)      Kaj Äe dobimo recimo
                        â†“ op (ğ‘‰ , match... )
                        ÄŒe nimamo navedenega pravila, naredimo korak v match..., 
                        dokler ne dobimo Å¾eljenega pravila za interupt propagation?

                DA, â†“ op (ğ‘‰ , ...) je evalvacijski kontekst, zato se ta, notri naprej delajo koraki

        b)      Kaj se zgodi Äe imamo 
                InProc(opA, e, Run promise opB ...as p in await p ...)    
                in pride od nekod opB, e  
                ~>
                InProc(opB, e,   InProc(opA, e, Run promise opB ...as p in await p ...)   ) 
                ~>
                InProc(opB, e,  Run  InComp(opA, e, promise opB ...as p in await p ...)   ) 
                ~> (tu je tudi varianta v Run (Incomp A (Incomp B (...))))
                InProc(opB, e,  Run  promise opB ...as p in InComp(opA, e, await p ...)   ) 
                ~>
                Run InComp(opB, e, promise opB ...as p in InComp(opA, e, await p ...)   ) 
                ~>
                Run let p = ... in InComp(opB, e, InComp(opA, e, await p ...))
                ~>
                ...
                

                                     