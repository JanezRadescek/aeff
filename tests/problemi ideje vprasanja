3 problem spremenljivke addition.aeff problem Runtime error: Integer expected but got a. a je topdef in tipa int. Problem je ker parser prepozna konstanto kot funkcijo.

19 
        let (id : 'a -> 'a) x = x
        let (compare : 'a -> 'b -> bool) a b =
                let a1 = id a in
                1a = b //tu je napaka uporabnika (mislil je a1 namesto 1a). 
                        //To napako aeff napaÄno zazna in se pritoÅ¾i, da ne more 1 uporabiti na a.
                        // Aeff bi moral reÄi spremenljivka 1a ne obstaja. 
        run compare 5 "7"

20      let (compare : 'a -> 'b -> bool) a b =
                let (id : 'a -> 'a) x = x in
                let a1 = id a in
                a1 = b
        run compare 5 "7"

        vrne error. Samo topleveldef imajo obliko (f : tip) = abs
                                preostale imajo obliko f = (abs : tip)




22      TODO podaj typecheckerju tudi LOC


24      Bomo med vgrajene funkcije dodali getTy?

25      Kako narediti nov interpreter?  
        imamo process list skupaj z listener
        vsak process se lahko izvaja concurent/paralel/sequantial
        normalno izvajamo dokler ni IN/OUT
        Ko dobimo v enem processu OUT ga obrnemo v IN in ga poÅ¡ljemo na svojem mesto
        Kako poÅ¡iljati in?
                ÄŒe si shranimo kje toÄno ga rabimo ga tja damo.
                ÄŒe pa ne potem pa kako? Si res Å¾elimo broadcast ali bi raje 1-1.? ÄŒe 1-1 kdo dobi Äe je veÄ?
                        V DO poskusimo najrej prvemu sicer?
                        V match gremo lahko rekurzivno v vsakega
                        Kako v tuple?  

26      GO example

        var results = chanel<int>()
        var inits = chanel<int>()
        var f () =
        {
                var init_1 <- inits
                var result_1 = SlowFunction_1( init_1 )
                results <- result_1
                var init_2 <- inipts
                var result_2 = SlowFunction_2( init_2 )
                results <- result_2
        } 
        //f mora vraÄati unit
        go f

        init <- 1
        ...working some staff
        init <- 2


        var r0 = SlowFunction_3( 3 ) //
        print(SlowFunction_3 is finished)

        var r1 <- results
        print(SlowFunction_1 is finished too)

        var r2 <- results
        print(All SlowFunctions are finished)

        return (r1, r2)




        AEFF counter part

        operation results : int
        operation inits : int

        let f : unit -> unit =

                let promise inits i |-> i
                as inits_promise in

                await <<inits_promise>> until init_1 in   
                let result_1 = SlowFunction_1( init_1 ) in
                send result result_1;

                await <<inits_promise>> until init_2 in
                let result_2 = SlowFunction_2( init_2 ) in
                send result result_2

        run f()

        run     promise result r |-> r
                as p in return p

                send inits 1;
                ...working some staff
                in
                send inits 2;

                let r0 = SlowFunction_3( 3 )
                let _ = send print "SlowFunction_3 is finished" return() in

                await <<p>> until r1 in 
                send print "SlowFunction_1 is finished too" return() in

                await <<p>> until r2 in
                send print "All SlowFunctions are finished" return() in

                return (r1,r2)


28      na strani 24:6 asyn eff kaj je batchSizeResponse? ni to operacija, ki je nismo nikjer definirali?


29      24:11   Ground type ğ´, ğµ ::= ... brez A -> B 

        we assign a fixed signature op : ğ´op that specifies the type ğ´op of the payload
of the corresponding signal or interrupt. Crucially, in order to be able to later prove that ğœ†Ã¦ is type
safe (see Theorem 3.3, but also the relevant discussion in Section 6), we restrict these signatures to
ground types ğ´, ğµ, . . ., which include standard base, unit, empty, product, and sum types.

        ampak 
        async.aeff 
        ima
        operation question : unit -> int

30      line coments in aeff??

31      op <- v 
        sugar za 
        send op v 

        in obratno

        v <- op
        sugar za
        promise op v' |-> v' as p in
        await <<p>> until v
        ???

32      Kaj se zgodi Äe imamo InProc(opB, e,  InProc(opA, e, Run await op11 ...await opX...)  ) kjer je X = 1|2 {A,B} = {1,2}

        Namesto InProc = op * e * process
        bi imeli ali 
                InProc = (op * e) list * process //seznam operacij ki Äakajo da jih nekam damo
                ali
                process = (op * e) list * (op * e) list * comp//seznam in, seznam out, computation?


33      V "shared memory"/state so samo toplet, tydef, opdef ? torej lahko vsakemu threadu na zaÄetku damo svoj state in od zdej naprej vsak skrbi za svojega?
        Sedaj bi bilo dosti enostavno delati nove threade? Novemu threadu samo damo kopijo state in predpisan computation?


34      Kaj se zgodi Äe op = op' v
        Commutativity of signals with interrupt handlers 24:9
        promise (op ğ‘¥ â†¦â†’ ğ‘€) as ğ‘ in â†‘ opâ€²
        (ğ‘‰ , ğ‘) { â†‘ opâ€²
        (ğ‘‰ , promise (op ğ‘¥ â†¦â†’ ğ‘€) as ğ‘ in ğ‘)
        ?


35      V interpreter je povno moÅ¾nosti, ki niso moÅ¾ne, glede na to, da ima program tip.
        Vendar tega match ne ve in mu moramo podati insert. 
        Se da kako povedati match da bi to prepoznal avtomatsko?


