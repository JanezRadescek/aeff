3 problem spremenljivke addition.aeff problem Runtime error: Integer expected but got a. a je topdef in tipa int. Problem je ker parser prepozna konstanto kot funkcijo.

19 
        let (id : 'a -> 'a) x = x
        let (compare : 'a -> 'b -> bool) a b =
                let a1 = id a in
                1a = b //tu je napaka uporabnika (mislil je a1 namesto 1a). 
                        //To napako aeff napačno zazna in se pritoži, da ne more 1 uporabiti na a.
                        // Aeff bi moral reči spremenljivka 1a ne obstaja. 
        run compare 5 "7"

20      let (compare : 'a -> 'b -> bool) a b =
                let (id : 'a -> 'a) x = x in
                let a1 = id a in
                a1 = b
        run compare 5 "7"

        vrne error. Samo topleveldef imajo obliko (f : tip) = abs
                                preostale imajo obliko f = (abs : tip)




22      TODO podaj typecheckerju tudi LOC


24      Bomo med vgrajene funkcije dodali getTy?

25      Kako narediti nov interpreter?  
        imamo process list skupaj z listener
        vsak process se lahko izvaja concurent/paralel/sequantial
        normalno izvajamo dokler ni IN/OUT
        Ko dobimo v enem processu OUT ga obrnemo v IN in ga pošljemo na svojem mesto
        Kako pošiljati in?
                Če si shranimo kje točno ga rabimo ga tja damo.
                Če pa ne potem pa kako? Si res želimo broadcast ali bi raje 1-1.? Če 1-1 kdo dobi če je več?
                        V DO poskusimo najrej prvemu sicer?
                        V match gremo lahko rekurzivno v vsakega
                        Kako v tuple?  

