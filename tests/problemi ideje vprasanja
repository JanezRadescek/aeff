3 problem spremenljivke addition.aeff problem Runtime error: Integer expected but got a. a je topdef in tipa int. Problem je ker parser prepozna konstanto kot funkcijo.

19 
        let (id : 'a -> 'a) x = x
        let (compare : 'a -> 'b -> bool) a b =
                let a1 = id a in
                1a = b //tu je napaka uporabnika (mislil je a1 namesto 1a). 
                        //To napako aeff napačno zazna in se pritoži, da ne more 1 uporabiti na a.
                        // Aeff bi moral reči spremenljivka 1a ne obstaja. 
        run compare 5 "7"

20      let (compare : 'a -> 'b -> bool) a b =
                let (id : 'a -> 'a) x = x in
                let a1 = id a in
                a1 = b
        run compare 5 "7"

        vrne error. Samo topleveldef imajo obliko (f : tip) = abs
                                preostale imajo obliko f = (abs : tip)



22      TODO podaj typecheckerju tudi LOC


24      Bomo med vgrajene funkcije dodali getTy?



25      Kako izvajamo program?  
        normalno izvajamo dokler ni IN/OUT
        Ko dobimo v enem processu OUT ga pošljemo ven in obrnemo v IN v drugih. 
        Kako pošiljati in?
                Če si shranimo promise. Kako si jih shranimo? promise bi moral biti ovit v comp, 
                ki bi imel shranjen pointer na naslednjo comp, 
                da bi lahko ta comp(promise) zamenjali z do. ne pa vrednosti
                
        Do takrat pointerjev ali gruge rešitve.
                kako izvajati OUT

                        Kaj se zgodi če op = op' v
                        Commutativity of signals with interrupt handlers 24:9
                        promise (op 𝑥 ↦→ 𝑀) as 𝑝 in ↑ op′
                        (𝑉 , 𝑁) { ↑ op′
                        (𝑉 , promise (op 𝑥 ↦→ 𝑀) as 𝑝 in 𝑁)
                        ?

                        Out lahko vedno takoj pošljemo ven do konca?

                Kako izvajati IN

                        36

                        

                        Namesto InProc = op * e * process
                                bi imeli ali 
                                        InProc = (op * e) list * process //seznam operacij ki čakajo da jih nekam damo
                                        ali
                                        process = (op * e) list * (op * e) list * comp//seznam in, seznam out, computation?


26      GO example

        var results = chanel<int>()
        var inits = chanel<int>()
        var f () =
        {
                var init_1 <- inits
                var result_1 = SlowFunction_1( init_1 )
                results <- result_1
                var init_2 <- inipts
                var result_2 = SlowFunction_2( init_2 )
                results <- result_2
        } 
        //f mora vračati unit
        go f()

        init <- 1
        ...working some staff
        init <- 2


        var r0 = SlowFunction_3( 3 ) //
        print(SlowFunction_3 is finished)

        var r1 <- results
        print(SlowFunction_1 is finished too)

        var r2 <- results
        print(All SlowFunctions are finished)

        return (r1, r2)




        AEFF counter part

        operation results : int
        operation inits : int

        let f : unit -> unit =
            let promise inits init_1 |-> (
              let result_1 = SlowFunction_1( init_1 ) in
              send result result_1;
              let promise inits init_2 |->
                let result_2 = SlowFunction_2( init_2 ) in
                send result result_2;
                return <<()>>
            )

        run f()

        run
          send inits 1;
          send inits 2;
          let r0 = SlowFunction_3( 3 ) in
          let _ = send print "SlowFunction_3 is finished" return() in
          promise results r1 |->

     promise result r |-> r
                as p in return p

                send inits 1;
                ...working some staff
                in
                send inits 2;

                let r0 = SlowFunction_3( 3 )

                await <<p>> until r1 in 
                send print "SlowFunction_1 is finished too" return() in

                await <<p>> until r2 in
                send print "All SlowFunctions are finished" return() in

                return (r1,r2)



29      24:11   Ground type 𝐴, 𝐵 ::= ... brez A -> B 

        we assign a fixed signature op : 𝐴op that specifies the type 𝐴op of the payload
of the corresponding signal or interrupt. Crucially, in order to be able to later prove that 𝜆æ is type
safe (see Theorem 3.3, but also the relevant discussion in Section 6), we restrict these signatures to
ground types 𝐴, 𝐵, . . ., which include standard base, unit, empty, product, and sum types.

        ampak 
        async.aeff 
        ima
        operation question : unit -> int



36      a)      Kaj če dobimo recimo
                        ↓ op (𝑉 , match... )
                        Če nimamo navedenega pravila, naredimo korak v match..., 
                        dokler ne dobimo željenega pravila za interupt propagation?

                DA, ↓ op (𝑉 , ...) je evalvacijski kontekst, zato se ta, notri naprej delajo koraki

        b)      Kaj se zgodi če imamo 
                InProc(opA, e, Run promise opB ...as p in await p ...)    
                in pride od nekod opB, e  
                ~>
                InProc(opB, e,   InProc(opA, e, Run promise opB ...as p in await p ...)   ) 
                ~>
                InProc(opB, e,  Run  InComp(opA, e, promise opB ...as p in await p ...)   ) 
                ~> (tu je tudi varianta v Run (Incomp A (Incomp B (...))))
                InProc(opB, e,  Run  promise opB ...as p in InComp(opA, e, await p ...)   ) 
                ~>
                Run InComp(opB, e, promise opB ...as p in InComp(opA, e, await p ...)   ) 
                ~>
                Run let p = ... in InComp(opB, e, InComp(opA, e, await p ...))
                ~>
                ...


37      čez kodo kar je že narejeno pa če je prava smer
        star interpreter sem v celoti zakomentiral, ker bi rad naredil od začetka, ker sicer bodo deli kode, ki bodo delali pa ne bom vedel zakaj, 
        potem se bo pa nekoč nekaj spremenilo, pa nebodo več delali, pa tudi ne bom vedel zakaj ali kako popraviti. 

        thread = run comp + seznam operacij, ki jih hočemo. stanje
        //glede na Danel verzijo gre seznam operacij ki jih poslušamo stran, in ga nadomestimo z pointerjem na global queue operacij.

        run initialize all and call run_rec 
        run_rec poganjaj induvidualne threade dokler se ne bodo prekinili. Resolve operation reši operacije in interupte. Če je kakšen thread, ki še ni končan se rekurzivno pokliči.
        run_thread Če smo Ready predaj run_comp
        run_comp rekurzivno izvajaj comp. in na koncu odloči v kakšnem stanju smo se ustavili.

        resolve operations vsem thredom, ki so op_out vzemi operacijo, jo daj na global queue in nato vsakemu thredu daj operacije, ki jih hoče, če jih hoče.
                                     